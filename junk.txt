
final List<String> nullableKeys = [
        "mealOfferingsAsUrl",
        "mealOfferingsAsList",
        "buildingFilterTag",
      ];
      foodSpotMap.forEach((key, value) => {
            // TODO: Appropriate Error Throw for "catch" to Handle
          });





/// we have the listOfJsonFoodSpots and the listOfJsonImages
/// 1.  we then create map with id to formatted foodspot (we need methods to: format foodspots, loop through listOfJsonFoodSpots to format foodspots and create the map)
/// 2.  we then create map with id to formatted images urls (we need methods to: format image url, loop through listOfJsonImages to format image url and create the map)



          import 'dart:convert';

import 'package:http/http.dart' as http;

import '../models/times_and_dates/operating_times.dart';
import 'contentful_repository.dart';

class FoodSpotRepository {
  FoodSpotRepository();

  /// * Ensure to call this method first when creating new instance of this class!
  Future<void> init() async {
    final allFoodSpotsResponse = await _getAllFoodSpotsResponse();

    try {
      final List foodSpotsJsonList = allFoodSpotsResponse["foodSpotsJsonList"]!;
      final List imagesJsonList = allFoodSpotsResponse["imagesJsonList"]!;

      /// Late initialization of our class properties

    } catch (e) {
      // TODO: Appropriate Error Handling
    }
  }

  /// Map containing keys and values of foodSpot ID and foodSpot respectively
  late List<dynamic> foodSpotsMapIdToFoodSpotsFormatted;

  /// Map containing keys and values of image ID and image URL respectively
  late Map<String> imagesMapIdToUrl;

  List<FoodSpotThumbnail> getAllFoodSpotThumbnails() {}

  /// When successful: this method returns a map of keys: "foodSpotsJsonList" and "imagesJsonList" containing
  /// the list of foodspot json objects and the list of image json objects respectively
  ///
  /// When failed:
  /// TODO: complete documentation
  Future<Map<String, List>> _getAllFoodSpotsResponse() async {
    /// My Postman Https Request Example:
    /// https://cdn.contentful.com/spaces/{{UVIC_FOODIES_SPACE_ID}}/entries?access_token={{UVIC_FOODIES_ACCESS_TOKEN}}&content_type={{UVIC_FOODIES_CONTENT_TYPE_ID_FOODSPOTS}}

    final queryParameters = {
      "access_token": ContentfulRepository.ACCESS_TOKEN,
      "content_type": ContentfulRepository.CONTENT_TYPE_FOODSPOT,
    };

    final uri = Uri.https(
      ContentfulRepository.BASE_URL,
      "spaces/${ContentfulRepository.SPACE_ID}/entries",
      queryParameters,
    );

    final client = http.Client();
    final response = await client.get(uri);

    // The "http" package instructs to run this method after client usage in order to prevent memory leak
    client.close();

    final json = jsonDecode(response.body);

    try {
      return {
        "foodSpotsJsonList": json["items"] as List,
        "imagesJsonList": json["includes"]["Asset"] as List,
      };
    } catch (e) {
      // TODO: Appropriate Error Handling
      rethrow;
    }
  }

  Map<String, dynamic> generateFoodSpotMap(
    Map<String, dynamic> json,
    DateTime dateTimeNow,
  ) {
    try {
      final foodSpotId = json["sys"]["id"];
      final fields = json["fields"];

      /// TODO: Too many keys, convert this to a class, and assert that one of the mealOfferings vars are null
      final foodSpotMap = {
        "id": foodSpotId,
        "name": fields["name"],
        "coverImageLinkId": fields["sys"]["id"],
        "paymentsByFlexPlan": fields["paymentsByFlexPlan"],
        "paymentsByMealPlan": fields["paymentsByMealPlan"],
        "mealOfferingsAsUrl": fields["mealOfferingsAsUrl"],
        "mealOfferingsAsList": List<String>.from(fields["mealOfferingsAsList"]),
        "locationPreposition": fields["locationPreposition"],
        "locationNearbyLandmark": fields["locationNearbyLandmark"],
        "buildingFilterTag": fields["buildingFilterTag"],
        "operatingTimes": OperatingTimes(
          foodSpotId: foodSpotId,
          dateTimeNow: dateTimeNow,
          monHoursWithDash: fields["hoursMonday"],
          tueHoursWithDash: fields["hoursTuesday"],
          wedHoursWithDash: fields["hoursWednesday"],
          thuHoursWithDash: fields["hoursThursday"],
          friHoursWithDash: fields["hoursFriday"],
          satHoursWithDash: fields["hoursSaturday"],
          sunHoursWithDash: fields["hoursSunday"],
        )
      };

      /// Assert the type of each key and that the only nullable keys are
      /// mealOfferingsAsUrl, mealOfferingsAsList, buildingFilterTag
      assert(foodSpotMap["id"] is String &&
          foodSpotMap["name"] is String &&
          foodSpotMap["coverImageLinkId"] is String &&
          foodSpotMap["paymentsByFlexPlan"] is bool &&
          foodSpotMap["paymentsByMealPlan"] is bool &&
          (foodSpotMap["mealOfferingsAsUrl"] is String ||
              foodSpotMap["mealOfferingsAsUrl"] == null) &&
          (foodSpotMap["mealOfferingsAsList"] is List<String> ||
              foodSpotMap["mealOfferingsAsList"] == null) &&
          foodSpotMap["locationPreposition"] is String &&
          foodSpotMap["locationNearbyLandmark"] is String &&
          (foodSpotMap["buildingFilterTag"] is String ||
              foodSpotMap["buildingFilterTag"] == null) &&
          foodSpotMap["operatingTimes"] is OperatingTimes);

      return foodSpotMap;
    } catch (e) {
      // TODO: Appropriate Error Handling
      rethrow;
    }
  }

  String generateImageUrl(Map<String, dynamic> json) {
    return "https:${json["fields"]["file"]["url"]}";
  }
}
